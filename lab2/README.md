# Lab 2 - Set Covering using GA 

This solution has been developed in collaboration with my colleague Andrea D'Attila (303339).

We tried to solve the Set Covering problem using a Genetic Algorithm.
Starting from the lists generated by `problem` using `seed = 42`, we removed duplicated lists, which are useless in order to find a solution.

## Representation
The first step of the algorithm consists in generating the population. 
We have used a binary representation: each genome contains a list of 0 and 1. A 0 in the i-th position of the genome means that the i-th list of the problem has not been included; a 1 in the i-th position of the genome means that the i-th list of the problem has been included. 
To generate the population, we created genomes containing all 0s, which means that we start our algorithm having coverage and weight equal to 0. Then, in next generations, we tried to add some 1s randomically and see the evolution.

## Fitness
Genomes are evaluated using a `fitness` function. In this case, we have assigned to each genome a tuple `(c,-w)`, in which the first value represent the **coverage** of that genome, which corresponds to the number of different values covered by that particulare genome; the second value represent the **weigth** of that genome, which is the total number of values included in that genome, considering duplicates too. 
We have added a minus to the weigth, so that when comparing two genomes, the best is the one with the higher coverage. If two genomes have the same coverage, the best is the one with the lower weight.

## Algorithm Parameters
After running the GA using different parameters, we have chosen the ones which gave us the best results in a reasonable time. We used `POPULATION SIZE = 1500` and `OFFSPRING SIZE = 1000`.
In our Genetic Algorithm we used both **mutation** and **crossover**: for each generation we generate mutated offsprings with `mutation rate = 0.3`. 

We used as a stopping condition a maximum number of generations, which we set to 200. If we obtain an optimal solution (N=coverage=weight) before reaching the maximum number of generations, we stop the algorithm.

## Results
These are the results we obtained using these parameters:
- N = 5, weight = 5, bloat = 0%, generations = 3 (**optimal solution**)
- N = 10, weight = 10, bloat = 0%, generations = 7 (**optimal solution**)
- N = 20, weight = 24, bloat = 20%, generations = 200
- N = 100, weight = 202, bloat = 102%, generations = 200
- N = 500, weight = 1610, bloat = 222%, generations = 200
- N = 1000, weight = 3600, bloat = 260%, generations = 200
